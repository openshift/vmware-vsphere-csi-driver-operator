package testlib

import (
	"context"
	"crypto/tls"
	"fmt"
	"net/url"
	"os"
	"path"

	"github.com/vmware/govmomi/vapi/rest"
	"k8s.io/klog/v2"

	goruntime "runtime"

	ocpv1 "github.com/openshift/api/config/v1"
	"github.com/openshift/vmware-vsphere-csi-driver-operator/pkg/operator/vclib"
	"github.com/vmware/govmomi"
	"github.com/vmware/govmomi/find"
	pdbsimulator "github.com/vmware/govmomi/pbm/simulator"
	"github.com/vmware/govmomi/simulator"
	vapisimulator "github.com/vmware/govmomi/vapi/simulator"
	"github.com/vmware/govmomi/vim25/types"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	DefaultModel  = "testlib/testdata/default"
	DefaultVMPath = "/DC0/vm/"
)

type simulatedVM struct {
	name, uuid string
}

var (
	// Virtual machines generated by vSphere simulator. UUIDs look generated, but they're stable.
	DefaultVMs = []simulatedVM{
		{"DC0_H0_VM0", "265104de-1472-547c-b873-6dc7883fb6cb"},
		{"DC0_H0_VM1", "39365506-5a0a-5fd0-be10-9586ad53aaad"},
	}
	DefaultHostId = "host-24" // Generated by vcsim
)

// change directory so as we can use relative path starting from operator root for finding test data files
func init() {
	_, filename, _, _ := goruntime.Caller(0)
	dir := path.Join(path.Dir(filename), "..")
	err := os.Chdir(dir)
	if err != nil {
		panic(err)
	}
}

func SetupSimulator(modelDir string, infra *ocpv1.Infrastructure) ([]*vclib.VSphereConnection, func(), error) {
	var connections []*vclib.VSphereConnection
	var servers []*simulator.Server
	var models []*simulator.Model

	createdVCs := make(map[string]*vclib.VSphereConnection)
	if infra.Spec.PlatformSpec.VSphere != nil && len(infra.Spec.PlatformSpec.VSphere.FailureDomains) > 0 {
		fmt.Printf("Adding connections via FD\n")
		for _, fd := range infra.Spec.PlatformSpec.VSphere.FailureDomains {
			if createdVCs[fd.Server] == nil {
				conn, server, model, err := createConnection(modelDir, fd.Server)
				if err != nil {
					return nil, nil, err
				}
				connections = append(connections, conn)
				servers = append(servers, server)
				models = append(models, model)
			}
		}
	} else {
		// This is testcase for when no FDs are defined.  Default back to old behavior.
		fmt.Printf("Adding connections via NON FD\n")
		conn, server, model, err := createConnection(modelDir, "foobar.lan")
		if err != nil {
			return nil, nil, err
		}
		connections = append(connections, conn)
		servers = append(servers, server)
		models = append(models, model)
	}

	cleanup := func() {
		for _, s := range servers {
			s.Close()
		}
		for _, model := range models {
			model.Remove()
		}
	}
	return connections, cleanup, nil
}

func createConnection(modelDir, server string) (*vclib.VSphereConnection, *simulator.Server, *simulator.Model, error) {
	model := simulator.VPX()
	err := model.Load(modelDir)
	if err != nil {
		return nil, nil, nil, err
	}
	model.Service.TLS = new(tls.Config)

	s := model.Service.NewServer()
	// Set pdbsimulator to provide APIs for storage policy creation and manipulation.
	model.Service.RegisterSDK(pdbsimulator.New())

	client, err := ConnectToSimulator(s)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to connect to the similator: %s", err)
	}

	// setup VAPI handlers to provide APIs for tags and categories
	patterns, handlers := vapisimulator.New(client.URL(), simulator.Map)
	for _, p := range patterns {
		model.Service.Handle(p, handlers)
	}

	conn := &vclib.VSphereConnection{
		Config:   simulatorConfig(),
		Client:   client,
		Username: "admin@vsphere.local",
		Password: "foobar",
		Hostname: server,
		Insecure: true,
	}

	userInfo := url.UserPassword(conn.Username, conn.Password)
	restClient := rest.NewClient(client.Client)
	err = restClient.Login(context.TODO(), userInfo)
	if err != nil {
		msg := fmt.Sprintf("error logging into vcenter RESTful services: %v", err)
		klog.Error(msg)
	}
	conn.RestClient = restClient

	return conn, s, model, nil
}

func ConnectToSimulator(s *simulator.Server) (*govmomi.Client, error) {
	client, err := govmomi.NewClient(context.TODO(), s.URL, true)
	if err != nil {
		return nil, err
	}
	return client, nil
}

func Node(name string, modifiers ...func(*v1.Node)) *v1.Node {
	n := &v1.Node{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
		Spec: v1.NodeSpec{
			ProviderID: "",
		},
	}
	for _, modifier := range modifiers {
		modifier(n)
	}
	return n
}

func WithProviderID(id string) func(*v1.Node) {
	return func(node *v1.Node) {
		node.Spec.ProviderID = id
	}
}

func DefaultNodes() []*v1.Node {
	var nodes []*v1.Node
	for _, vm := range DefaultVMs {
		node := Node(vm.name, WithProviderID("vsphere://"+vm.uuid))
		nodes = append(nodes, node)
	}
	return nodes
}

func simulatorConfig() *vclib.VSphereConfig {
	var cfg vclib.VSphereConfig
	data := cloudProviderConfig()
	err := cfg.LoadConfig(data)
	if err != nil {
		panic(err)
	}
	return &cfg
}

func cloudProviderConfig() string {
	// Configuration that corresponds to the simulated vSphere
	return `[Global]
secret-name = "vsphere-creds"
secret-namespace = "kube-system"
insecure-flag = "1"

[Workspace]
server = "localhost"
datacenter = "DC0"
default-datastore = "LocalDS_0"
folder = "/DC0/vm"

[VirtualCenter "dc0"]
datacenters = "DC0"
`
}

func CustomizeVCenterVersion(version string, apiVersion string, conn *vclib.VSphereConnection) {
	conn.Client.Client.ServiceContent.About.Version = version
	conn.Client.Client.ServiceContent.About.ApiVersion = apiVersion
	fmt.Printf("customize vcenter version")
}

func SetHWVersion(conn *vclib.VSphereConnection, node *v1.Node, hardwareVersion string) error {
	err := CustomizeVM(conn, node, &types.VirtualMachineConfigSpec{
		ExtraConfig: []types.BaseOptionValue{
			&types.OptionValue{
				Key: "SET.config.version", Value: hardwareVersion,
			},
		}})
	return err
}

func CustomizeVM(conn *vclib.VSphereConnection, node *v1.Node, spec *types.VirtualMachineConfigSpec) error {
	finder := find.NewFinder(conn.Client.Client, true)
	vm, err := finder.VirtualMachine(context.TODO(), DefaultVMPath+node.Name)
	if err != nil {
		return err
	}

	task, err := vm.Reconfigure(context.TODO(), *spec)
	if err != nil {
		return err
	}

	err = task.Wait(context.TODO())
	return err
}

func CustomizeHostVersion(hostSystemId string, version string) error {
	hsRef := simulator.Map.Get(types.ManagedObjectReference{
		Type:  "HostSystem",
		Value: hostSystemId,
	})
	if hsRef == nil {
		return fmt.Errorf("can't find HostSystem %s", hostSystemId)
	}

	hs := hsRef.(*simulator.HostSystem)
	hs.Config.Product.Version = version
	hs.Config.Product.ApiVersion = version
	return nil
}
